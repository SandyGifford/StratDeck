{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/server/ConnectedPlayer.ts","webpack:///./src/server/GameStateManager.ts","webpack:///./src/server/initialGameState.ts","webpack:///./src/server/routing.ts","webpack:///./src/server/server.ts","webpack:///./src/server/socketStuff.ts","webpack:///./src/shared/emitTypes.ts","webpack:///./src/shared/utils/ArrayUtils.ts","webpack:///./src/shared/utils/DeckUtils.ts","webpack:///./src/shared/utils/EventDelegate.ts","webpack:///./src/shared/utils/LoopUtils.ts","webpack:///./src/shared/utils/PlayerUtils.ts","webpack:///external \"express\"","webpack:///external \"http\"","webpack:///external \"path\"","webpack:///external \"socket.io\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkD;AACR;AACC;AACF;AACI;AAC7C,OAAO,uBAAuB,GAAG,yDAAS;AAC3B;AACf;AACA;AACA;AACA,2BAA2B,4BAA4B,uBAAuB,YAAY,SAAS,6BAA6B;AAChI,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,sCAAsC,uBAAuB,yCAAyC,UAAU;AAChH;AACA;AACA,kCAAkC,uBAAuB,YAAY,WAAW;AAChF,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,sCAAsC,uBAAuB,+CAA+C,UAAU;AACtH;AACA;AACA,kCAAkC,uBAAuB;AACzD,YAAY,yDAAgB;AAC5B;AACA;AACA,+CAA+C,gBAAgB;AAC/D,2BAA2B,yDAAgB;AAC3C;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB,iBAAiB,yDAAU;AAClG;AACA;AACA,iCAAiC;AACjC,YAAY,0DAAW;AACvB,kCAAkC,yDAAgB;AAClD,kCAAkC,uBAAuB,IAAI,wBAAwB,iGAAiG,cAAc;AACpM;AACA,uBAAuB,4BAA4B;AACnD,gDAAgD,yDAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAgB;AAC/B;AACA;AACA,kDAAkD,yCAAyC,gBAAgB,UAAU,EAAE,kBAAkB;AACzI;AACA;AACA;AACA,wCAAwC,aAAa,EAAE,2BAA2B;AAClF;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAS;AACxB;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACI;AACO;AACzC;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAgB;AACzC;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,mCAAmC;AAClD,+BAA+B,0DAAW;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,QAAQ,0DAAW;AACnB,QAAQ,0DAAW;AACnB,QAAQ,0DAAW;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,UAAU;AACzB;AACA,QAAQ,0DAAW;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAa;AACnD,qCAAqC,4DAAa;AAClD;;;;;;;;;;;;;ACrFA;AAAA;AAAyC;AACzC;AACA,aAAa,wDAAS;AACtB,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACc,+EAAgB,EAAC;;;;;;;;;;;;;ACXhC;AAAA;AAAA;AAAA;AAAA;AAAmC;AACN;AAC7B,YAAY,oCAAO;AACnB,wCAAwC,yCAAS;AACjD,gDAAgD,yCAAS;AACzD,+CAA+C,yCAAS;AACzC,kEAAG,EAAC;;;;;;;;;;;;;ACNnB;AAAA;AAAA;AAAA;AAAA;AAAA;AACmC;AACK;AACR;AAChC,YAAY,oCAAO;AACnB,eAAe,mBAAO,CAAC,kBAAM;AAC7B,4DAAW;AACX,QAAQ,gDAAO;AACf;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAwD;AACd;AACM;AAChD,OAAO,aAAa,GAAG,yDAAS;AACjB;AACf,eAAe,mBAAO,CAAC,4BAAW;AAClC,IAAI,gEAAgB;AACpB,IAAI,gEAAgB;AACpB;AACA;AACA,YAAY,wDAAe;AAC3B,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAA;AAAe;AACf;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAe;AACf;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAyC;AACE;AAC5B;AACf;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA,YAAY,wDAAS;AACrB;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,QAAQ,wDAAS;AACjB;AACA;AACA,QAAQ,wDAAS;AACjB,sBAAsB,yDAAU;AAChC;AACA;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA,+BAA+B,WAAW,uDAAuD,SAAS,uDAAuD,KAAK;AACtK;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC;AACA;AACA;AACA,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C,qBAAqB,0BAA0B;AAC/C,qBAAqB,0BAA0B;AAC/C;AACA;AACA,wGAAwG,gBAAgB;AACxH;AACA;AACA;;;;;;;;;;;;ACjEA,oC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC","file":"server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/server/server.ts\");\n","import GameStateManager from \"./GameStateManager\";\nimport emitTypes from \"@shared/emitTypes\";\nimport ArrayUtils from \"@utils/ArrayUtils\";\nimport LoopUtils from \"@utils/LoopUtils\";\nimport PlayerUtils from \"@utils/PlayerUtils\";\nconst { fromServer, toServer } = emitTypes;\nexport default class ConnectedPlayer {\n    constructor(socket) {\n        this.socket = socket;\n        this.resetGame = (playerCount) => {\n            console.log(`${this.getPlayerDisplayText()} reset the game with ${playerCount} player${playerCount === 1 ? \"\" : \"s\"}`);\n            GameStateManager.resetGame(playerCount);\n        };\n        this.buyCard = (boughtCard) => {\n            if (!this.isMyTurn()) {\n                console.log(`Player ${this.getPlayerNumber()} tried to buy a card out of turn.`);\n                return;\n            }\n            const playPhase = GameStateManager.getPlayPhase();\n            if (playPhase !== \"buy\") {\n                console.log(`Player ${this.getPlayerNumber()} tried to buy a card but play phase is ${playPhase}.`);\n                return;\n            }\n            console.log(`Player ${this.getPlayerNumber()} bought a ${boughtCard} card.`);\n            GameStateManager.buyCard(this.playerIndex, boughtCard);\n        };\n        this.moveChars = (moves) => {\n            if (!this.isMyTurn()) {\n                console.log(`Player ${this.getPlayerNumber()} tried to move their chars out of turn.`);\n                return;\n            }\n            const playPhase = GameStateManager.getPlayPhase();\n            if (playPhase !== \"move\") {\n                console.log(`Player ${this.getPlayerNumber()} tried to move their chars but play phase is ${playPhase}.`);\n                return;\n            }\n            console.log(`Player ${this.getPlayerNumber()} moved their chars.`);\n            GameStateManager.moveChars(this.playerIndex, moves);\n        };\n        this.initialize = (playerIndex, partialPlayerState) => {\n            console.log(`initializing player ${playerIndex + 1}`, partialPlayerState);\n            const player = GameStateManager.getPlayer(playerIndex);\n            if (player) {\n                console.log(`Attempt to initialize player ${playerIndex + 1} failed.  Player is already initialized.`);\n                return;\n            }\n            this.playerIndex = playerIndex;\n            this.playerName = partialPlayerState.name;\n            const playerState = Object.assign({}, partialPlayerState, { hand: [], deck: ArrayUtils.shuffle([\n                    ...this.makeCards(6, \"hand\"),\n                    ...this.makeCards(4, \"weapon\")\n                ]), discard: [] });\n            PlayerUtils.dealCards(playerState, 5);\n            const waitinOnCount = GameStateManager.initializePlayer(playerIndex, playerState);\n            console.log(`Player ${this.getPlayerNumber()} (${partialPlayerState.name}) has selected characters, ` + (waitinOnCount === 0 ? \"all players ready\" : (`still waiting on ${waitinOnCount} player` + (waitinOnCount === 1 ? \"\" : \"s\"))));\n        };\n        console.log(`${this.getPlayerDisplayText()} connected`);\n        socket.emit(fromServer.playerConnected, GameStateManager.getGameState());\n        socket.on(toServer.resetGame, this.resetGame);\n        socket.on(toServer.initializePlayer, this.initialize);\n        socket.on(toServer.buyCard, this.buyCard);\n        socket.on(toServer.moveChars, this.moveChars);\n    }\n    getPlayerNumber() {\n        return this.playerIndex + 1;\n    }\n    isMyTurn() {\n        return GameStateManager.isPlayersTurn(this.playerIndex);\n    }\n    getPlayerDisplayText() {\n        return this.getNumberedPlayerText() + `(${typeof this.playerName === \"string\" ? `${this.playerName} @ ` : \"\"}${this.getAddress()})`;\n    }\n    getNumberedPlayerText(noTrailingSpace) {\n        const playerNumber = this.getPlayerNumber();\n        return playerNumber ? `player ${playerNumber}${noTrailingSpace ? \"\" : \" \"}` : \"\";\n    }\n    getAddress() {\n        return this.socket.handshake.address;\n    }\n    makeCards(num, type) {\n        return LoopUtils.mapTimes(num, () => type);\n    }\n}\n","import PlayerUtils from \"@utils/PlayerUtils\";\nimport EventDelegate from \"@utils/EventDelegate\";\nimport initialGameState from \"@server/initialGameState\";\nexport default class GameStateManager {\n    static addUpdateListener(listener) {\n        this.updateDelegate.addEventListener(listener);\n    }\n    static removeUpdateListener(listener) {\n        this.updateDelegate.removeEventListener(listener);\n    }\n    static addResetListener(listener) {\n        this.resetDelegate.addEventListener(listener);\n    }\n    static removeResetListener(listener) {\n        this.resetDelegate.removeEventListener(listener);\n    }\n    static updateGameState(newGameState) {\n        this.gameState = newGameState;\n        this.updateDelegate.trigger(this.gameState);\n    }\n    static resetGame(playerCount) {\n        this.gameState = initialGameState(playerCount);\n        this.resetDelegate.trigger(this.gameState);\n    }\n    static updatePartialGameState(partialGameState) {\n        const newGameState = Object.assign({}, this.gameState);\n        Object.keys(partialGameState).forEach((key) => {\n            newGameState[key] = partialGameState[key];\n        });\n        this.updateGameState(newGameState);\n    }\n    static initializePlayer(playerIndex, playerState) {\n        const { players, boardWidth, boardHeight } = this.gameState;\n        players[playerIndex] = PlayerUtils.makeTablePlayer(playerState, playerIndex, boardWidth, boardHeight);\n        const waitingOnPlayers = players.reduce((playerCount, player) => {\n            if (player)\n                playerCount--;\n            return playerCount;\n        }, players.length);\n        const allPicked = waitingOnPlayers === 0;\n        GameStateManager.updatePartialGameState({\n            players: players,\n            screen: allPicked ? \"table\" : \"characterSelect\",\n        });\n        return waitingOnPlayers;\n    }\n    static buyCard(playerIndex, boughtCard) {\n        const { players } = this.gameState;\n        const player = players[playerIndex];\n        PlayerUtils.discardHand(player);\n        PlayerUtils.addCardToDiscard(player, boughtCard);\n        PlayerUtils.dealCards(player, 5);\n        GameStateManager.updatePartialGameState({\n            players: players,\n            playPhase: \"move\",\n        });\n    }\n    static moveChars(playerIndex, moves) {\n        const { players } = this.gameState;\n        const player = players[playerIndex];\n        PlayerUtils.moveChars(player, moves);\n        let { whosTurn } = this.gameState;\n        whosTurn = (whosTurn + 1) % this.gameState.playerCount;\n        GameStateManager.updatePartialGameState({\n            players: players,\n            whosTurn: whosTurn,\n            playPhase: \"buy\",\n        });\n    }\n    static getGameState() {\n        return this.gameState;\n    }\n    static getPlayer(playerIndex) {\n        return this.gameState.players[playerIndex];\n    }\n    static isPlayersTurn(playerIndex) {\n        return this.gameState.whosTurn === playerIndex;\n    }\n    static getPlayPhase() {\n        return this.gameState.playPhase;\n    }\n}\nGameStateManager.gameState = null;\nGameStateManager.updateDelegate = new EventDelegate();\nGameStateManager.resetDelegate = new EventDelegate();\n;\n","import LoopUtils from \"@utils/LoopUtils\";\nconst initialGameState = (playerCount) => ({\n    players: LoopUtils.mapTimes(playerCount, () => null),\n    playerReadyState: LoopUtils.mapTimes(playerCount, () => false),\n    screen: \"characterSelect\",\n    playerCount: playerCount,\n    playPhase: \"buy\",\n    whosTurn: 0,\n    boardHeight: 20,\n    boardWidth: 30,\n});\nexport default initialGameState;\n","import * as express from \"express\";\nimport * as path from \"path\";\nconst app = express();\napp.get(\"/\", (req, res) => res.sendFile(path.join(__dirname, \"../index.html\")));\napp.get(\"/assets/*\", (req, res) => res.sendFile(path.join(__dirname, \"../\", req.url)));\napp.get(\"/build/*\", (req, res) => res.sendFile(path.join(__dirname, \"../\", req.url)));\nexport default app;\n","console.clear();\nimport * as express from \"express\";\nimport SocketStuff from \"./socketStuff\";\nimport routing from \"./routing\";\nconst app = express();\nconst server = require(\"http\").Server(app);\nSocketStuff(server);\napp.use(routing);\nserver.listen(3000, \"0.0.0.0\");\n","import GameStateManager from \"@server/GameStateManager\";\nimport emitTypes from \"@shared/emitTypes\";\nimport ConnectedPlayer from \"./ConnectedPlayer\";\nconst { fromServer } = emitTypes;\nexport default (server) => {\n    const io = require(\"socket.io\")(server);\n    GameStateManager.addResetListener(gameState => io.emit(fromServer.gameReset, gameState));\n    GameStateManager.addUpdateListener(gameState => io.emit(fromServer.gameStateUpdated, gameState));\n    io.emit(fromServer.gameReset);\n    io.on(\"connection\", socket => {\n        new ConnectedPlayer(socket);\n    });\n};\n","export default {\n    fromServer: {\n        playerConnected: \"connection made\",\n        gameStateUpdated: \"game state updated\",\n        gameReset: \"game state reset\",\n    },\n    toServer: {\n        initializePlayer: \"initialize player state\",\n        resetGame: \"reset game\",\n        buyCard: \"buy card\",\n        moveChars: \"move chars\",\n    },\n};\n","export default class ArrayUtils {\n    static shuffle(arr) {\n        for (let i = arr.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n        }\n        return arr;\n    }\n}\n","export default class DeckUtils {\n    static dealAllCardsToDeck(fromDeck, toDeck) {\n        this.dealCardsToDeck(fromDeck, toDeck, fromDeck.length);\n    }\n    static dealCardsToDeck(fromDeck, toDeck, cardCount) {\n        const cards = DeckUtils.dealCards(fromDeck, cardCount);\n        this.addCardsToTop(toDeck, cards);\n    }\n    static dealCards(deck, cardCount) {\n        return deck.splice(-1 * cardCount);\n    }\n    static addCardsToTop(deck, cards) {\n        const multiCards = typeof cards === \"string\" ? [cards] : cards;\n        deck.push(...multiCards);\n    }\n    static addCardsToBottom(deck, cards) {\n        const multiCards = typeof cards === \"string\" ? [cards] : cards;\n        deck.unshift(...multiCards);\n    }\n}\n","export default class EventDelegate {\n    constructor() {\n        this.listeners = [];\n        this.trigger = (data) => {\n            this.listeners.forEach(listener => listener(data));\n        };\n    }\n    addEventListener(listener) {\n        if (this.listeners.indexOf(listener) === -1)\n            this.listeners.push(listener);\n        else\n            console.warn(\"Listner was already added.\");\n    }\n    removeEventListener(listener) {\n        const index = this.listeners.indexOf(listener);\n        if (index !== -1)\n            this.listeners.splice(index, 1);\n    }\n    clearEventListeners() {\n        this.listeners = [];\n    }\n    getListenerCount() {\n        return this.listeners.length;\n    }\n    hasListeners() {\n        return this.listeners.length !== 0;\n    }\n}\n","export default class LoopUtils {\n    static mapTimes(times, callback) {\n        const arr = [];\n        for (let i = 0; i < times; i++) {\n            arr.push(callback(i));\n        }\n        return arr;\n    }\n}\n","import DeckUtils from \"@utils/DeckUtils\";\nimport ArrayUtils from \"@utils/ArrayUtils\";\nexport default class PlayerUtils {\n    static dealCards(player, cardCount) {\n        const deckSize = player.deck.length;\n        if (cardCount > deckSize) {\n            DeckUtils.dealCardsToDeck(player.deck, player.hand, deckSize);\n            this.shuffleDiscardToDeck(player);\n            DeckUtils.dealCardsToDeck(player.deck, player.hand, cardCount - deckSize);\n        }\n        else {\n            DeckUtils.dealCardsToDeck(player.deck, player.hand, cardCount);\n        }\n    }\n    static discardHand(player) {\n        DeckUtils.dealAllCardsToDeck(player.hand, player.discard);\n    }\n    static shuffleDiscardToDeck(player) {\n        DeckUtils.dealAllCardsToDeck(player.discard, player.deck);\n        player.deck = ArrayUtils.shuffle(player.deck);\n    }\n    static addCardToDiscard(player, card) {\n        DeckUtils.addCardsToTop(player.discard, card);\n    }\n    static makeTablePlayer(player, playerIndex, boardWidth, boardHeight) {\n        const positions = this.getPlayerPosition(playerIndex, boardWidth, boardHeight);\n        return Object.assign({}, player, { chars: player.chars.map((char, c) => (Object.assign({}, char, { maxHP: char.hp, x: positions[c].x, y: positions[c].y }))) });\n    }\n    static moveChars(player, charMoves) {\n        player.chars.forEach((char, index) => {\n            const move = charMoves[index];\n            char.x = move.x;\n            char.y = move.y;\n        });\n    }\n    static getPlayerPosition(playerIndex, boardWidth, boardHeight) {\n        switch (playerIndex) {\n            case 0:\n                return [\n                    { x: 0, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 0, y: 2 },\n                ];\n            case 1:\n                return [\n                    { x: boardWidth - 1, y: boardHeight - 1 },\n                    { x: boardWidth - 1, y: boardHeight - 2 },\n                    { x: boardWidth - 1, y: boardHeight - 3 },\n                ];\n            case 2:\n                return [\n                    { x: 0, y: boardHeight - 1 },\n                    { x: 1, y: boardHeight - 1 },\n                    { x: 2, y: boardHeight - 1 },\n                ];\n            case 3:\n                return [\n                    { x: boardWidth - 1, y: 0 },\n                    { x: boardWidth - 2, y: 0 },\n                    { x: boardWidth - 3, y: 0 },\n                ];\n            default:\n                throw `Board does not support this many players.  Requested start location for player ${playerIndex + 1},  max player count is 2`;\n        }\n    }\n}\n","module.exports = require(\"express\");","module.exports = require(\"http\");","module.exports = require(\"path\");","module.exports = require(\"socket.io\");"],"sourceRoot":""}