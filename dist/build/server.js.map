{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/server/ConnectedPlayer.ts","webpack:///./src/server/GameStateManager.ts","webpack:///./src/server/initialGameState.ts","webpack:///./src/server/routing.ts","webpack:///./src/server/server.ts","webpack:///./src/server/socketStuff.ts","webpack:///./src/shared/emitTypes.ts","webpack:///./src/shared/utils/ArrayUtils.ts","webpack:///./src/shared/utils/CardUtils.ts","webpack:///./src/shared/utils/CharUtils.ts","webpack:///./src/shared/utils/DeckUtils.ts","webpack:///./src/shared/utils/EventDelegate.ts","webpack:///./src/shared/utils/GameUtils.ts","webpack:///./src/shared/utils/LoopUtils.ts","webpack:///./src/shared/utils/PlayerUtils.ts","webpack:///./src/shared/utils/UidUtils.ts","webpack:///external \"express\"","webpack:///external \"http\"","webpack:///external \"immutable\"","webpack:///external \"path\"","webpack:///external \"socket.io\"","webpack:///external \"uuid\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACW;AACR;AACC;AACF;AACI;AACJ;AACzC,OAAO,uBAAuB,GAAG,yDAAS;AAC3B;AACf;AACA;AACA;AACA,2BAA2B,4BAA4B,uBAAuB,YAAY,SAAS,6BAA6B;AAChI,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,sCAAsC,uBAAuB,yCAAyC,UAAU;AAChH;AACA;AACA,kCAAkC,uBAAuB,YAAY,WAAW;AAChF,YAAY,yDAAgB;AAC5B,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA,sCAAsC,uBAAuB,4BAA4B,cAAc;AACvG;AACA;AACA,gBAAgB,yDAAgB;AAChC,sCAAsC,uBAAuB,4BAA4B,cAAc;AACvG;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,sCAAsC,uBAAuB,+CAA+C,UAAU;AACtH;AACA;AACA,kCAAkC,uBAAuB,cAAc,cAAc,OAAO,OAAO,IAAI,OAAO;AAC9G,mCAAmC,yDAAgB;AACnD;AACA;AACA,gBAAgB,yDAAgB;AAChC,gBAAgB,yDAAgB;AAChC,gBAAgB,yDAAgB;AAChC;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D,2BAA2B,yDAAgB;AAC3C;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB,iBAAiB,yDAAU;AAChG;AACA;AACA,iCAAiC;AACjC,yCAAyC,0DAAW,WAAW,gDAAgB;AAC/E,qCAAqC,yDAAgB;AACrD;AACA,YAAY,yDAAgB;AAC5B,kCAAkC,uBAAuB,IAAI,wBAAwB,oGAAoG,iBAAiB;AAC1M;AACA,uBAAuB,4BAA4B;AACnD,gDAAgD,yDAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAgB;AAC/B;AACA;AACA,kDAAkD,yCAAyC,gBAAgB,UAAU,EAAE,kBAAkB;AACzI;AACA;AACA;AACA,wCAAwC,aAAa,EAAE,2BAA2B;AAClF;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAS,qBAAqB,wDAAS;AACtD;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD;AACoB;AAC5B;AACA;AAC1B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0FAAyB;AAClD;AACA;AACA;AACA;AACA,oBAAoB,wDAAS;AAC7B,iCAAiC,wDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAS,+CAA+C,wDAAS;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAS;AACjC,oBAAoB,wDAAS;AAC7B,+BAA+B,wDAAS;AACxC;AACA,wBAAwB,wDAAS;AACjC,wBAAwB,wDAAS;AACjC;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAa;AACnD,qCAAqC,4DAAa;AAClD;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACE;AACzC;AACA,aAAa,wDAAS;AACtB,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,mDAAmD,gDAAgB;AAC3D,+EAAgB,EAAC;;;;;;;;;;;;;ACbhC;AAAA;AAAA;AAAA;AAAA;AAA8B;AACD;AAC7B,YAAY,8CAAO;AACnB,wCAAwC,yCAAS;AACjD,gDAAgD,yCAAS;AACzD,+CAA+C,yCAAS;AACzC,kEAAG,EAAC;;;;;;;;;;;;;ACNnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8B;AACU;AACR;AAChC,YAAY,8CAAO;AACnB,eAAe,mBAAO,CAAC,kBAAM;AAC7B;AACA,4DAAW;AACX,QAAQ,gDAAO;AACf;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAwD;AACd;AACM;AAChD,OAAO,aAAa,GAAG,yDAAS;AACjB;AACf,eAAe,mBAAO,CAAC,4BAAW;AAClC,IAAI,gEAAgB;AACpB,IAAI,gEAAgB;AACpB;AACA;AACA,YAAY,wDAAe;AAC3B,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAA;AAAA;AAAA;AAAuC;AACxB;AACf;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACL;AACnB;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iDAAQ;AACzB;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAwC;AACzB;AACf;AACA,uBAAuB,oDAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,oDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAW;AAC1B;AACA;AACA,eAAe,oDAAW;AAC1B;AACA;AACA,uBAAuB,oDAAW;AAClC;AACA;AACA;AACA;AACA,4BAA4B,oDAAW;AACvC;AACA;AACA;AACA;AACA,uBAAuB,oDAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,oDAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,oDAAW;AAClC;AACA;AACA;AACA;AACA,eAAe,oDAAW;AAC1B;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACE;AACE;AACP;AACrB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAS,sCAAsC,gDAAgB;AACpG;AACA;AACA;AACA;AACA;AACA,kDAAkD,kDAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,kDAAS;AACxB;AACA;AACA,qBAAqB,kDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC;AACA;AACA;AACA,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C,qBAAqB,0BAA0B;AAC/C,qBAAqB,0BAA0B;AAC/C;AACA;AACA,wGAAwG,gBAAgB;AACxH;AACA;AACA;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACO;AACrB;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uCAAO;AACtB,oBAAoB,kDAAS;AAC7B,SAAS;AACT;AACA;;;;;;;;;;;;ACbA,oC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,iC","file":"server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/server/server.ts\");\n","import * as Immutable from \"immutable\";\nimport GameStateManager from \"./GameStateManager\";\nimport emitTypes from \"@shared/emitTypes\";\nimport ArrayUtils from \"@utils/ArrayUtils\";\nimport LoopUtils from \"@utils/LoopUtils\";\nimport PlayerUtils from \"@utils/PlayerUtils\";\nimport CardUtils from \"@utils/CardUtils\";\nconst { fromServer, toServer } = emitTypes;\nexport default class ConnectedPlayer {\n    constructor(socket) {\n        this.socket = socket;\n        this.resetGame = (playerCount) => {\n            console.log(`${this.getPlayerDisplayText()} reset the game with ${playerCount} player${playerCount === 1 ? \"\" : \"s\"}`);\n            GameStateManager.resetGame(playerCount);\n        };\n        this.buyCard = (boughtCard) => {\n            if (!this.isMyTurn()) {\n                console.log(`Player ${this.getPlayerNumber()} tried to buy a card out of turn.`);\n                return;\n            }\n            const playPhase = GameStateManager.getPlayPhase();\n            if (playPhase !== \"buy\") {\n                console.log(`Player ${this.getPlayerNumber()} tried to buy a card but play phase is ${playPhase}.`);\n                return;\n            }\n            console.log(`Player ${this.getPlayerNumber()} bought a ${boughtCard} card.`);\n            GameStateManager.buyCard(this.playerIndex, boughtCard);\n            GameStateManager.setPlayPhase(\"move\");\n        };\n        this.moveChar = (charIndex, move) => {\n            if (!this.isMyTurn()) {\n                console.log(`Player ${this.getPlayerNumber()} tried to move their char ${charIndex + 1} out of turn.`);\n                return;\n            }\n            if (GameStateManager.getCharDidMoveThisTurn(this.playerIndex, charIndex)) {\n                console.log(`Player ${this.getPlayerNumber()} tried to move their char ${charIndex + 1} but that char has moved already.`);\n                return;\n            }\n            const playPhase = GameStateManager.getPlayPhase();\n            if (playPhase !== \"move\") {\n                console.log(`Player ${this.getPlayerNumber()} tried to move their chars but play phase is ${playPhase}.`);\n                return;\n            }\n            console.log(`Player ${this.getPlayerNumber()} moved char ${charIndex + 1} to (${move.x}, ${move.y}).`);\n            const waitingOnChars = GameStateManager.moveChar(this.playerIndex, charIndex, move);\n            const allMoved = waitingOnChars === 0;\n            if (allMoved) {\n                GameStateManager.setAllCharMovedThisTurn(this.playerIndex, false);\n                GameStateManager.setPlayPhase(\"buy\");\n                GameStateManager.incrementTurn();\n            }\n        };\n        this.initialize = (playerIndex, partialPlayerState) => {\n            console.log(`initializing player ${playerIndex + 1}`, partialPlayerState);\n            const player = GameStateManager.getPlayer(playerIndex);\n            if (player) {\n                console.log(`Attempt to initialize player ${playerIndex + 1} failed.  Player is already initialized.`);\n                return;\n            }\n            this.playerIndex = playerIndex;\n            this.playerName = partialPlayerState.name;\n            let playerState = Object.assign({}, partialPlayerState, { hand: [], deck: ArrayUtils.shuffle([\n                    ...this.makeCards(6, \"hand\"),\n                    ...this.makeCards(4, \"weapon\")\n                ]), discard: [] });\n            const immutablePlayerState = PlayerUtils.dealCards(Immutable.fromJS(playerState), 5);\n            const waitingOnPlayers = GameStateManager.initializePlayer(playerIndex, immutablePlayerState);\n            const allPicked = waitingOnPlayers === 0;\n            GameStateManager.setGameScreen(allPicked ? \"table\" : \"characterSelect\");\n            console.log(`Player ${this.getPlayerNumber()} (${partialPlayerState.name}) has selected characters, ` + (waitingOnPlayers === 0 ? \"all players ready\" : (`still waiting on ${waitingOnPlayers} player` + (waitingOnPlayers === 1 ? \"\" : \"s\"))));\n        };\n        console.log(`${this.getPlayerDisplayText()} connected`);\n        socket.emit(fromServer.playerConnected, GameStateManager.getGameState());\n        socket.on(toServer.resetGame, this.resetGame);\n        socket.on(toServer.initializePlayer, this.initialize);\n        socket.on(toServer.buyCard, this.buyCard);\n        socket.on(toServer.moveChar, this.moveChar);\n    }\n    getPlayerNumber() {\n        return this.playerIndex + 1;\n    }\n    isMyTurn() {\n        return GameStateManager.isPlayersTurn(this.playerIndex);\n    }\n    getPlayerDisplayText() {\n        return this.getNumberedPlayerText() + `(${typeof this.playerName === \"string\" ? `${this.playerName} @ ` : \"\"}${this.getAddress()})`;\n    }\n    getNumberedPlayerText(noTrailingSpace) {\n        const playerNumber = this.getPlayerNumber();\n        return playerNumber ? `player ${playerNumber}${noTrailingSpace ? \"\" : \" \"}` : \"\";\n    }\n    getAddress() {\n        return this.socket.handshake.address;\n    }\n    makeCards(num, type) {\n        return LoopUtils.mapTimes(num, () => CardUtils.createCard(type));\n    }\n}\n","import EventDelegate from \"@utils/EventDelegate\";\nimport { immutableInitialGameState } from \"@server/initialGameState\";\nimport GameUtils from \"@utils/GameUtils\";\nimport CardUtils from \"@utils/CardUtils\";\nexport default class GameStateManager {\n    static addUpdateListener(listener) {\n        this.updateDelegate.addEventListener(listener);\n    }\n    static removeUpdateListener(listener) {\n        this.updateDelegate.removeEventListener(listener);\n    }\n    static addResetListener(listener) {\n        this.resetDelegate.addEventListener(listener);\n    }\n    static removeResetListener(listener) {\n        this.resetDelegate.removeEventListener(listener);\n    }\n    static updateGameState(newGameState) {\n        this.gameState = newGameState;\n        this.updateDelegate.trigger(this.gameState);\n    }\n    static resetGame(playerCount) {\n        this.gameState = immutableInitialGameState(playerCount);\n        this.resetDelegate.trigger(this.gameState);\n    }\n    static initializePlayer(playerIndex, playerState) {\n        let gameState = this.gameState;\n        gameState = GameUtils.convertPlayerToTablePlayer(gameState, playerState, playerIndex);\n        const waitingOnPlayers = GameUtils.countUnreadyPlayers(gameState);\n        GameStateManager.updateGameState(gameState);\n        return waitingOnPlayers;\n    }\n    static setGameScreen(screen) {\n        GameStateManager.updateGameState(this.gameState.set(\"screen\", screen));\n    }\n    static buyCard(playerIndex, boughtCard) {\n        const gameState = GameUtils.addCardToDiscard(this.gameState, playerIndex, CardUtils.createImmutableCard(boughtCard));\n        GameStateManager.updateGameState(gameState);\n    }\n    static setPlayPhase(gamePhase) {\n        GameStateManager.updateGameState(this.gameState.set(\"playPhase\", gamePhase));\n    }\n    static moveChar(playerIndex, charIndex, move) {\n        let gameState = GameUtils.moveChar(this.gameState, playerIndex, charIndex, move);\n        gameState = GameUtils.setCharMovedThisTurn(gameState, playerIndex, charIndex, true);\n        const waitingOnChars = GameUtils.countUnmovedCharacters(gameState, playerIndex);\n        if (waitingOnChars === 0) {\n            gameState = GameUtils.discardHand(gameState, playerIndex);\n            gameState = GameUtils.dealCards(gameState, playerIndex, 5);\n        }\n        GameStateManager.updateGameState(gameState);\n        return waitingOnChars;\n    }\n    static setAllCharMovedThisTurn(playerIndex, movedThisTurn) {\n        this.updateGameState(GameUtils.setAllCharMovedThisTurn(this.gameState, playerIndex, movedThisTurn));\n    }\n    static incrementTurn() {\n        let whosTurn = this.gameState.get(\"whosTurn\");\n        whosTurn = (whosTurn + 1) % this.gameState.get(\"playerCount\");\n        this.updateGameState(this.gameState.set(\"whosTurn\", whosTurn));\n    }\n    static getGameState() {\n        return this.gameState;\n    }\n    static getPlayer(playerIndex) {\n        return this.gameState.get(\"players\").get(playerIndex);\n    }\n    static isPlayersTurn(playerIndex) {\n        return this.gameState.get(\"whosTurn\") === playerIndex;\n    }\n    static getPlayPhase() {\n        return this.gameState.get(\"playPhase\");\n    }\n    static getCharDidMoveThisTurn(playerIndex, charIndex) {\n        return this.gameState.get(\"players\").get(playerIndex).get(\"chars\").get(charIndex).get(\"movedThisTurn\");\n    }\n}\nGameStateManager.gameState = null;\nGameStateManager.updateDelegate = new EventDelegate();\nGameStateManager.resetDelegate = new EventDelegate();\n;\n","import * as Immutable from \"immutable\";\nimport LoopUtils from \"@utils/LoopUtils\";\nconst initialGameState = (playerCount) => ({\n    players: LoopUtils.mapTimes(playerCount, () => null),\n    playerReadyState: LoopUtils.mapTimes(playerCount, () => false),\n    screen: \"characterSelect\",\n    playerCount: playerCount,\n    playPhase: \"buy\",\n    whosTurn: 0,\n    boardHeight: 20,\n    boardWidth: 30,\n});\nexport const immutableInitialGameState = (playerCount) => Immutable.fromJS(initialGameState(playerCount));\nexport default initialGameState;\n","import express from \"express\";\nimport * as path from \"path\";\nconst app = express();\napp.get(\"/\", (req, res) => res.sendFile(path.join(__dirname, \"../index.html\")));\napp.get(\"/assets/*\", (req, res) => res.sendFile(path.join(__dirname, \"../\", req.url)));\napp.get(\"/build/*\", (req, res) => res.sendFile(path.join(__dirname, \"../\", req.url)));\nexport default app;\n","console.clear();\nimport express from \"express\";\nimport SocketStuff from \"./socketStuff\";\nimport routing from \"./routing\";\nconst app = express();\nconst server = require(\"http\").Server(app);\nconst port = parseInt(process.env.PORT) || 3000;\nSocketStuff(server);\napp.use(routing);\nserver.listen(port, \"0.0.0.0\");\n","import GameStateManager from \"@server/GameStateManager\";\nimport emitTypes from \"@shared/emitTypes\";\nimport ConnectedPlayer from \"./ConnectedPlayer\";\nconst { fromServer } = emitTypes;\nexport default (server) => {\n    const io = require(\"socket.io\")(server);\n    GameStateManager.addResetListener((gameState) => io.emit(fromServer.gameReset, gameState.toJS()));\n    GameStateManager.addUpdateListener((gameState) => io.emit(fromServer.gameStateUpdated, gameState.toJS()));\n    io.emit(fromServer.gameReset);\n    io.on(\"connection\", socket => {\n        new ConnectedPlayer(socket);\n    });\n};\n","export default {\n    fromServer: {\n        playerConnected: \"connection made\",\n        gameStateUpdated: \"game state updated\",\n        gameReset: \"game state reset\",\n    },\n    toServer: {\n        initializePlayer: \"initialize player state\",\n        resetGame: \"reset game\",\n        buyCard: \"buy card\",\n        moveChar: \"move char\",\n    },\n};\n","import * as Immutable from \"immutable\";\nexport default class ArrayUtils {\n    /**\n     * Shuffles the values in an array\n     * @param array an array\n     * @returns an array made up of the elements of array in random order\n     */\n    static shuffle(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n    // TODO: rewrite this as a proper immutable function\n    /**\n     * Shuffles the values in an Immutable LIst\n     * @param list an Immutable List\n     * @returns an Immutable List made up of the elements of list in random order\n     */\n    static shuffleImmutable(list) {\n        // ughhh\n        return Immutable.fromJS(this.shuffle(list.toJS()));\n    }\n    static removeAtIndex(array, index, size = 1) {\n        return array.slice(0, index).concat(array.slice(index + size));\n    }\n    // TODO: positive I can do this in better time\n    /**\n     * Checks (with strict equals) if all values in array are unique\n     * @param arr an array\n     * @returns true if all values in array are unique, otherwise false\n     */\n    static hasOnlyUniqueValues(arr) {\n        return arr.every((val, index) => {\n            const trimmed = this.removeAtIndex(arr, index);\n            return !trimmed.includes(val);\n        });\n    }\n}\n","import * as Immutable from \"immutable\";\nimport UidUtils from \"./UidUtils\";\nexport default class CardUtils {\n    /**\n     * Creates an Immutable CardState from card type.  Generates random UID for it\n     * @param type The type of the card\n     * @returns A new Immutable CardState with type type\n     */\n    static createImmutableCard(type, uidSeed) {\n        return Immutable.fromJS(this.createCard(type, uidSeed));\n    }\n    /**\n     * Creates a CardState from card type.  Generates random UID for it\n     * @param type The type of the card\n     * @returns A new CardState with type type\n     */\n    static createCard(type, uidSeed) {\n        return {\n            type: type,\n            uid: UidUtils.generate(uidSeed),\n        };\n    }\n}\n","export default class CharUtils {\n    /**\n     * Changes the location of a character\n     * @param character A character\n     * @param move The new location\n     * @returns an Immutable character at the new location\n     */\n    static moveChar(character, move) {\n        return character.set(\"x\", move.x).set(\"y\", move.y);\n    }\n    /**\n     * Changes an ImmutableCharacterDef to an ImmutableTableCharacterDef\n     * @param character The character base\n     * @param position The position to start the character at\n     * @returns a new ImmutableTableCharacterDef\n     */\n    static convertToTableChar(character, position) {\n        return character\n            .set(\"maxHP\", character.get(\"hp\"))\n            .set(\"x\", position.x)\n            .set(\"y\", position.y)\n            .set(\"movedThisTurn\", false);\n    }\n    /**\n     * Counts how man players haven't moved yet in this turn\n     * @param chars An Immutable list of characters\n     * @returns The numbe of characters who have not moved yet\n     */\n    static countUnmovedCharacters(chars) {\n        return chars.reduce((charCount, char) => {\n            if (char.get(\"movedThisTurn\"))\n                charCount--;\n            return charCount;\n        }, chars.size);\n    }\n}\n","export default class DeckUtils {\n    /**\n     * Deals all cards from one deck onto the top of another\n     * @param fromDeck The deck to deal cards from\n     * @param toDeck The deck to deal cards to\n     * @returns an object with the after states of both decks\n     */\n    static dealAllCardsToDeck(fromDeck, toDeck) {\n        return this.dealCardsToDeck(fromDeck, toDeck, fromDeck.size);\n    }\n    /**\n     * Deals cards from one deck onto the top of another\n     * @param fromDeck The deck to deal cards from\n     * @param toDeck The deck to deal cards to\n     * @param cardCount The number of cards to deal\n     * @returns an object with the after states of both decks\n     */\n    static dealCardsToDeck(fromDeck, toDeck, cardCount) {\n        const dealtCards = DeckUtils.dealCards(fromDeck, cardCount);\n        const newToDeck = this.addCardsToTop(toDeck, dealtCards.dealt);\n        return { fromDeck: dealtCards.deck, toDeck: newToDeck };\n    }\n    /**\n     * Removes cards from the top of a deck, returns them\n     * @param deck The deck to deal from\n     * @param cardCount The number of cards to deal\n     * @returns an object with the after state of the deck as well as the cards dealt\n     */\n    static dealCards(deck, cardCount) {\n        return {\n            deck: deck.slice(0, -cardCount),\n            dealt: deck.slice(-cardCount),\n        };\n    }\n    /**\n     * Adds cards to the top of a deck\n     * @param deck The deck to add to\n     * @param cards The cards to add\n     * @returns The new deck state\n     */\n    static addCardsToTop(deck, cards) {\n        return deck.concat(cards);\n    }\n    /**\n     * Adds cards to the bottom of a deck\n     * @param deck The deck to add to\n     * @param cards The cards to add\n     * @returns The new deck state\n     */\n    static addCardsToBottom(deck, cards) {\n        return cards.concat(deck);\n    }\n}\n","export default class EventDelegate {\n    constructor() {\n        this.listeners = [];\n        this.trigger = (data) => {\n            this.listeners.forEach(listener => listener(data));\n        };\n    }\n    addEventListener(listener) {\n        if (this.listeners.indexOf(listener) === -1)\n            this.listeners.push(listener);\n        else\n            console.warn(\"Listner was already added.\");\n    }\n    removeEventListener(listener) {\n        const index = this.listeners.indexOf(listener);\n        if (index !== -1)\n            this.listeners.splice(index, 1);\n    }\n    clearEventListeners() {\n        this.listeners = [];\n    }\n    getListenerCount() {\n        return this.listeners.length;\n    }\n    hasListeners() {\n        return this.listeners.length !== 0;\n    }\n}\n","import PlayerUtils from \"./PlayerUtils\";\nexport default class Gameutils {\n    static dealCards(gameState, playerIndex, cardCount) {\n        const player = PlayerUtils.dealCards(gameState.get(\"players\").get(playerIndex), cardCount);\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static moveChar(gameState, playerIndex, charIndex, move) {\n        const player = PlayerUtils.moveCharInPlayer(gameState.get(\"players\").get(playerIndex), charIndex, move);\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static setPlayer(gameState, playerIndex, player) {\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static countUnreadyPlayers(gameState) {\n        return PlayerUtils.countUnreadyPlayers(gameState.get(\"players\"));\n    }\n    static countUnmovedCharacters(gameState, playerIndex) {\n        return PlayerUtils.countUnmovedCharacters(gameState.get(\"players\").get(playerIndex));\n    }\n    static setAllCharMovedThisTurn(gameState, playerIndex, movedThisTurn) {\n        const player = PlayerUtils.setAllCharMovedThisTurn(gameState.get(\"players\").get(playerIndex), movedThisTurn);\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static convertPlayerToTablePlayer(gameState, player, playerIndex) {\n        const tablePlayer = PlayerUtils.convertPlayerToTablePlayer(player, playerIndex, gameState.get(\"boardWidth\"), gameState.get(\"boardHeight\"));\n        const players = gameState.get(\"players\").set(playerIndex, tablePlayer);\n        return gameState.set(\"players\", players);\n    }\n    static discardHand(gameState, playerIndex) {\n        const player = PlayerUtils.discardHand(gameState.get(\"players\").get(playerIndex));\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static addCardToDiscard(gameState, playerIndex, card) {\n        const player = PlayerUtils.addCardToDiscard(gameState.get(\"players\").get(playerIndex), card);\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static setCharMovedThisTurn(gameState, playerIndex, charIndex, movedThisTurn) {\n        const player = PlayerUtils.setCharMovedThisTurn(gameState.get(\"players\").get(playerIndex), charIndex, movedThisTurn);\n        const players = gameState.get(\"players\").set(playerIndex, player);\n        return gameState.set(\"players\", players);\n    }\n    static allMovesTaken(gameState, playerIndex) {\n        return PlayerUtils.allMovesTaken(gameState.get(\"players\").get(playerIndex));\n    }\n}\n","export default class LoopUtils {\n    /**\n     * Creates an array of elements\n     * @param times the number of elements\n     * @param callback called once per element\n     * @returns array!\n     */\n    static mapTimes(times, callback) {\n        const arr = [];\n        for (let i = 0; i < times; i++) {\n            arr.push(callback(i));\n        }\n        return arr;\n    }\n}\n","import * as Immutable from \"immutable\";\nimport DeckUtils from \"@utils/DeckUtils\";\nimport ArrayUtils from \"@utils/ArrayUtils\";\nimport CharUtils from \"./CharUtils\";\nexport default class PlayerUtils {\n    static dealCards(player, cardCount) {\n        const deckSize = player.get(\"deck\").size;\n        if (cardCount > deckSize) {\n            player = this.dealCardsFromDeckToDeck(player, \"deck\", \"hand\", deckSize);\n            player = this.shuffleDiscardToDeck(player);\n            player = this.dealCardsFromDeckToDeck(player, \"deck\", \"hand\", cardCount - deckSize);\n        }\n        else {\n            player = this.dealCardsFromDeckToDeck(player, \"deck\", \"hand\", cardCount);\n        }\n        return player;\n    }\n    static dealCardsFromDeckToDeck(player, fromDeck, toDeck, cardCount) {\n        const fromTo = DeckUtils.dealCardsToDeck(player.get(fromDeck), player.get(toDeck), cardCount);\n        player = player.set(fromDeck, fromTo.fromDeck);\n        player = player.set(toDeck, fromTo.toDeck);\n        return player;\n    }\n    static dealAllCardsFromDeckToDeck(player, fromDeck, toDeck) {\n        return this.dealCardsFromDeckToDeck(player, fromDeck, toDeck, player.get(fromDeck).size);\n    }\n    static shuffleDeck(player, deckType) {\n        return player.set(deckType, ArrayUtils.shuffleImmutable(player.get(deckType)));\n    }\n    static discardHand(player) {\n        return this.dealAllCardsFromDeckToDeck(player, \"hand\", \"discard\");\n    }\n    static shuffleDiscardToDeck(player) {\n        player = this.dealAllCardsFromDeckToDeck(player, \"discard\", \"deck\");\n        return this.shuffleDeck(player, \"deck\");\n    }\n    static addCardToDiscard(player, card) {\n        return player.set(\"discard\", DeckUtils.addCardsToTop(player.get(\"discard\"), Immutable.fromJS([card])));\n    }\n    static convertPlayerToTablePlayer(player, playerIndex, boardWidth, boardHeight) {\n        const positions = this.getPlayerPosition(playerIndex, boardWidth, boardHeight);\n        const tablePlayer = player;\n        const chars = player.get(\"chars\");\n        const tableChars = chars.map((char, c) => CharUtils.convertToTableChar(char, positions[c]));\n        // FIXME: baaaad typing\n        return tablePlayer.set(\"chars\", tableChars);\n    }\n    static countUnreadyPlayers(players) {\n        return players.reduce((playerCount, player) => {\n            if (player)\n                playerCount--;\n            return playerCount;\n        }, players.size);\n    }\n    static countUnmovedCharacters(player) {\n        return CharUtils.countUnmovedCharacters(player.get(\"chars\"));\n    }\n    static moveCharInPlayer(player, charIndex, move) {\n        const char = CharUtils.moveChar(player.get(\"chars\").get(charIndex), move);\n        const chars = player.get(\"chars\").set(charIndex, char);\n        return player.set(\"chars\", chars);\n    }\n    static setAllCharMovedThisTurn(player, movedThisTurn) {\n        const chars = player.get(\"chars\").map(char => char.set(\"movedThisTurn\", movedThisTurn));\n        return player.set(\"chars\", chars);\n    }\n    static setCharMovedThisTurn(player, charIndex, movedThisTurn) {\n        const char = player.get(\"chars\").get(charIndex).set(\"movedThisTurn\", movedThisTurn);\n        const chars = player.get(\"chars\").set(charIndex, char);\n        return player.set(\"chars\", chars);\n    }\n    static allMovesTaken(player) {\n        return player.get(\"chars\").every(char => char.get(\"movedThisTurn\"));\n    }\n    static getPlayerPosition(playerIndex, boardWidth, boardHeight) {\n        switch (playerIndex) {\n            case 0:\n                return [\n                    { x: 0, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 0, y: 2 },\n                ];\n            case 1:\n                return [\n                    { x: boardWidth - 1, y: boardHeight - 1 },\n                    { x: boardWidth - 1, y: boardHeight - 2 },\n                    { x: boardWidth - 1, y: boardHeight - 3 },\n                ];\n            case 2:\n                return [\n                    { x: 0, y: boardHeight - 1 },\n                    { x: 1, y: boardHeight - 1 },\n                    { x: 2, y: boardHeight - 1 },\n                ];\n            case 3:\n                return [\n                    { x: boardWidth - 1, y: 0 },\n                    { x: boardWidth - 2, y: 0 },\n                    { x: boardWidth - 3, y: 0 },\n                ];\n            default:\n                throw `Board does not support this many players.  Requested start location for player ${playerIndex + 1},  max player count is 2`;\n        }\n    }\n}\n","import * as uuid from \"uuid\";\nimport LoopUtils from \"./LoopUtils\";\nexport default class UidUtils {\n    /**\n     * Generate a random UID\n     * @param seed a seed for the UID generation, NOTE: THIS DOES NOT DO A GOOD JOB OF UTILIZING THE SEED, ONLY USE THIS FOR TEESTING\n     * @returns a uid\n     */\n    static generate(seed) {\n        return uuid.v4(typeof seed === \"number\" ? {\n            random: LoopUtils.mapTimes(16, i => seed + i),\n        } : undefined);\n    }\n}\n","module.exports = require(\"express\");","module.exports = require(\"http\");","module.exports = require(\"immutable\");","module.exports = require(\"path\");","module.exports = require(\"socket.io\");","module.exports = require(\"uuid\");"],"sourceRoot":""}