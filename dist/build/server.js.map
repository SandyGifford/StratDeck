{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/server/ConnectedPlayer.ts","webpack:///./src/server/GameStateManager.ts","webpack:///./src/server/initialGameState.ts","webpack:///./src/server/routing.ts","webpack:///./src/server/server.ts","webpack:///./src/server/socketStuff.ts","webpack:///./src/shared/emitTypes.ts","webpack:///./src/shared/utils/ArrayUtils.ts","webpack:///./src/shared/utils/DeckUtils.ts","webpack:///./src/shared/utils/EventDelegate.ts","webpack:///./src/shared/utils/LoopUtils.ts","webpack:///./src/shared/utils/PlayerUtils.ts","webpack:///external \"express\"","webpack:///external \"http\"","webpack:///external \"immutable\"","webpack:///external \"path\"","webpack:///external \"socket.io\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACW;AACR;AACC;AACF;AACI;AAC7C,OAAO,uBAAuB,GAAG,yDAAS;AAC3B;AACf;AACA;AACA;AACA,2BAA2B,4BAA4B,uBAAuB,YAAY,SAAS,6BAA6B;AAChI,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA,8BAA8B,yDAAgB;AAC9C;AACA,sCAAsC,uBAAuB,yCAAyC,UAAU;AAChH;AACA;AACA,kCAAkC,uBAAuB,YAAY,WAAW;AAChF,YAAY,yDAAgB;AAC5B;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB,+CAA+C,UAAU;AACtH;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D,2BAA2B,yDAAgB;AAC3C;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB,iBAAiB,yDAAU;AAChG;AACA;AACA,iCAAiC;AACjC,yCAAyC,0DAAW,WAAW,gDAAgB;AAC/E,mCAAmC,yDAAgB;AACnD,kCAAkC,uBAAuB,IAAI,wBAAwB,kGAAkG,eAAe;AACtM;AACA,uBAAuB,4BAA4B;AACnD,gDAAgD,yDAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAgB;AAC/B;AACA;AACA,kDAAkD,yCAAyC,gBAAgB,UAAU,EAAE,kBAAkB;AACzI;AACA;AACA;AACA,wCAAwC,aAAa,EAAE,2BAA2B;AAClF;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAS;AACxB;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACI;AACoB;AACtD;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0FAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAW;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB,QAAQ,0DAAW;AACnB,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAa;AACnD,qCAAqC,4DAAa;AAClD;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACE;AACzC;AACA,aAAa,wDAAS;AACtB,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,mDAAmD,gDAAgB;AAC3D,+EAAgB,EAAC;;;;;;;;;;;;;ACbhC;AAAA;AAAA;AAAA;AAAA;AAAmC;AACN;AAC7B,YAAY,oCAAO;AACnB,wCAAwC,yCAAS;AACjD,gDAAgD,yCAAS;AACzD,+CAA+C,yCAAS;AACzC,kEAAG,EAAC;;;;;;;;;;;;;ACNnB;AAAA;AAAA;AAAA;AAAA;AAAA;AACmC;AACK;AACR;AAChC,YAAY,oCAAO;AACnB,eAAe,mBAAO,CAAC,kBAAM;AAC7B,4DAAW;AACX,QAAQ,gDAAO;AACf;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAwD;AACd;AACM;AAChD,OAAO,aAAa,GAAG,yDAAS;AACjB;AACf,eAAe,mBAAO,CAAC,4BAAW;AAClC,IAAI,gEAAgB;AACpB,IAAI,gEAAgB;AACpB;AACA;AACA,YAAY,wDAAe;AAC3B,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAA;AAAA;AAAA;AAAuC;AACxB;AACf;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAgB;AAC/B;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAuC;AACxB;AACf;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gDAAgB;AACvE;AACA;AACA;AACA,uDAAuD,gDAAgB;AACvE;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAe;AACf;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACE;AACE;AAC5B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,uBAAuB,gDAAgB;AACvC,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC,qBAAqB,aAAa;AAClC;AACA;AACA,uBAAuB,gDAAgB;AACvC,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D,qBAAqB,wCAAwC;AAC7D;AACA;AACA,uBAAuB,gDAAgB;AACvC,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD;AACA;AACA,uBAAuB,gDAAgB;AACvC,qBAAqB,0BAA0B;AAC/C,qBAAqB,0BAA0B;AAC/C,qBAAqB,0BAA0B;AAC/C;AACA;AACA,wGAAwG,gBAAgB;AACxH;AACA;AACA;;;;;;;;;;;;AC3FA,oC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC","file":"server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/server/server.ts\");\n","import * as Immutable from \"immutable\";\nimport GameStateManager from \"./GameStateManager\";\nimport emitTypes from \"@shared/emitTypes\";\nimport ArrayUtils from \"@utils/ArrayUtils\";\nimport LoopUtils from \"@utils/LoopUtils\";\nimport PlayerUtils from \"@utils/PlayerUtils\";\nconst { fromServer, toServer } = emitTypes;\nexport default class ConnectedPlayer {\n    constructor(socket) {\n        this.socket = socket;\n        this.resetGame = (playerCount) => {\n            console.log(`${this.getPlayerDisplayText()} reset the game with ${playerCount} player${playerCount === 1 ? \"\" : \"s\"}`);\n            GameStateManager.resetGame(playerCount);\n        };\n        this.buyCard = (boughtCard) => {\n            if (!this.isMyTurn()) {\n                console.log(`Player ${this.getPlayerNumber()} tried to buy a card out of turn.`);\n                return;\n            }\n            const playPhase = GameStateManager.getPlayPhase();\n            if (playPhase !== \"buy\") {\n                console.log(`Player ${this.getPlayerNumber()} tried to buy a card but play phase is ${playPhase}.`);\n                return;\n            }\n            console.log(`Player ${this.getPlayerNumber()} bought a ${boughtCard} card.`);\n            GameStateManager.buyCard(this.playerIndex, boughtCard);\n        };\n        this.moveChars = (moves) => {\n            // if (!this.isMyTurn()) {\n            // \tconsole.log(`Player ${this.getPlayerNumber()} tried to move their chars out of turn.`);\n            // \treturn;\n            // }\n            // const playPhase = GameStateManager.getPlayPhase();\n            // if (playPhase !== \"move\") {\n            // \tconsole.log(`Player ${this.getPlayerNumber()} tried to move their chars but play phase is ${playPhase}.`);\n            // \treturn;\n            // }\n            // console.log(`Player ${this.getPlayerNumber()} moved their chars.`);\n            // GameStateManager.moveChars(this.playerIndex, moves);\n        };\n        this.initialize = (playerIndex, partialPlayerState) => {\n            console.log(`initializing player ${playerIndex + 1}`, partialPlayerState);\n            const player = GameStateManager.getPlayer(playerIndex);\n            if (player) {\n                console.log(`Attempt to initialize player ${playerIndex + 1} failed.  Player is already initialized.`);\n                return;\n            }\n            this.playerIndex = playerIndex;\n            this.playerName = partialPlayerState.name;\n            let playerState = Object.assign({}, partialPlayerState, { hand: [], deck: ArrayUtils.shuffle([\n                    ...this.makeCards(6, \"hand\"),\n                    ...this.makeCards(4, \"weapon\")\n                ]), discard: [] });\n            const immutablePlayerState = PlayerUtils.dealCards(Immutable.fromJS(playerState), 5);\n            const waitingOnCount = GameStateManager.initializePlayer(playerIndex, immutablePlayerState);\n            console.log(`Player ${this.getPlayerNumber()} (${partialPlayerState.name}) has selected characters, ` + (waitingOnCount === 0 ? \"all players ready\" : (`still waiting on ${waitingOnCount} player` + (waitingOnCount === 1 ? \"\" : \"s\"))));\n        };\n        console.log(`${this.getPlayerDisplayText()} connected`);\n        socket.emit(fromServer.playerConnected, GameStateManager.getGameState());\n        socket.on(toServer.resetGame, this.resetGame);\n        socket.on(toServer.initializePlayer, this.initialize);\n        socket.on(toServer.buyCard, this.buyCard);\n        socket.on(toServer.moveChars, this.moveChars);\n    }\n    getPlayerNumber() {\n        return this.playerIndex + 1;\n    }\n    isMyTurn() {\n        return GameStateManager.isPlayersTurn(this.playerIndex);\n    }\n    getPlayerDisplayText() {\n        return this.getNumberedPlayerText() + `(${typeof this.playerName === \"string\" ? `${this.playerName} @ ` : \"\"}${this.getAddress()})`;\n    }\n    getNumberedPlayerText(noTrailingSpace) {\n        const playerNumber = this.getPlayerNumber();\n        return playerNumber ? `player ${playerNumber}${noTrailingSpace ? \"\" : \" \"}` : \"\";\n    }\n    getAddress() {\n        return this.socket.handshake.address;\n    }\n    makeCards(num, type) {\n        return LoopUtils.mapTimes(num, () => type);\n    }\n}\n","import PlayerUtils from \"@utils/PlayerUtils\";\nimport EventDelegate from \"@utils/EventDelegate\";\nimport { immutableInitialGameState } from \"@server/initialGameState\";\nexport default class GameStateManager {\n    static addUpdateListener(listener) {\n        this.updateDelegate.addEventListener(listener);\n    }\n    static removeUpdateListener(listener) {\n        this.updateDelegate.removeEventListener(listener);\n    }\n    static addResetListener(listener) {\n        this.resetDelegate.addEventListener(listener);\n    }\n    static removeResetListener(listener) {\n        this.resetDelegate.removeEventListener(listener);\n    }\n    static updateGameState(newGameState) {\n        this.gameState = newGameState;\n        this.updateDelegate.trigger(this.gameState);\n    }\n    static resetGame(playerCount) {\n        this.gameState = immutableInitialGameState(playerCount);\n        this.resetDelegate.trigger(this.gameState);\n    }\n    static initializePlayer(playerIndex, playerState) {\n        const players = this.gameState.get(\"players\");\n        const boardWidth = this.gameState.get(\"boardWidth\");\n        const boardHeight = this.gameState.get(\"boardHeight\");\n        players.set(playerIndex, PlayerUtils.makeTablePlayer(playerState, playerIndex, boardWidth, boardHeight));\n        const waitingOnPlayers = players.reduce((playerCount, player) => {\n            if (player)\n                playerCount--;\n            return playerCount;\n        }, players.size);\n        const allPicked = waitingOnPlayers === 0;\n        let gameState = this.gameState;\n        gameState = gameState.set(\"players\", players);\n        gameState = gameState.set(\"screen\", allPicked ? \"table\" : \"characterSelect\");\n        GameStateManager.updateGameState(gameState);\n        return waitingOnPlayers;\n    }\n    static buyCard(playerIndex, boughtCard) {\n        const players = this.gameState.get(\"players\");\n        const player = players.get(playerIndex);\n        PlayerUtils.addCardToDiscard(player, boughtCard);\n        let gameState = this.gameState;\n        gameState = gameState.set(\"players\", players);\n        gameState = gameState.set(\"playPhase\", \"move\");\n        GameStateManager.updateGameState(gameState);\n    }\n    static moveChars(playerIndex, moves) {\n        const players = this.gameState.get(\"players\");\n        let whosTurn = this.gameState.get(\"whosTurn\");\n        const player = players.get(playerIndex);\n        PlayerUtils.moveChars(player, moves);\n        PlayerUtils.discardHand(player);\n        PlayerUtils.dealCards(player, 5);\n        whosTurn = (whosTurn + 1) % this.gameState.get(\"playerCount\");\n        let gameState = this.gameState;\n        gameState = gameState.set(\"players\", players);\n        gameState = gameState.set(\"whosTurn\", whosTurn);\n        gameState = gameState.set(\"playPhase\", \"buy\");\n        GameStateManager.updateGameState(gameState);\n    }\n    static getGameState() {\n        return this.gameState;\n    }\n    static getPlayer(playerIndex) {\n        return this.gameState.get(\"players\").get(playerIndex);\n    }\n    static isPlayersTurn(playerIndex) {\n        return this.gameState.get(\"whosTurn\") === playerIndex;\n    }\n    static getPlayPhase() {\n        return this.gameState.get(\"playPhase\");\n    }\n}\nGameStateManager.gameState = null;\nGameStateManager.updateDelegate = new EventDelegate();\nGameStateManager.resetDelegate = new EventDelegate();\n;\n","import * as Immutable from \"immutable\";\nimport LoopUtils from \"@utils/LoopUtils\";\nconst initialGameState = (playerCount) => ({\n    players: LoopUtils.mapTimes(playerCount, () => null),\n    playerReadyState: LoopUtils.mapTimes(playerCount, () => false),\n    screen: \"characterSelect\",\n    playerCount: playerCount,\n    playPhase: \"buy\",\n    whosTurn: 0,\n    boardHeight: 20,\n    boardWidth: 30,\n});\nexport const immutableInitialGameState = (playerCount) => Immutable.fromJS(initialGameState(playerCount));\nexport default initialGameState;\n","import * as express from \"express\";\nimport * as path from \"path\";\nconst app = express();\napp.get(\"/\", (req, res) => res.sendFile(path.join(__dirname, \"../index.html\")));\napp.get(\"/assets/*\", (req, res) => res.sendFile(path.join(__dirname, \"../\", req.url)));\napp.get(\"/build/*\", (req, res) => res.sendFile(path.join(__dirname, \"../\", req.url)));\nexport default app;\n","console.clear();\nimport * as express from \"express\";\nimport SocketStuff from \"./socketStuff\";\nimport routing from \"./routing\";\nconst app = express();\nconst server = require(\"http\").Server(app);\nSocketStuff(server);\napp.use(routing);\nserver.listen(3000, \"0.0.0.0\");\n","import GameStateManager from \"@server/GameStateManager\";\nimport emitTypes from \"@shared/emitTypes\";\nimport ConnectedPlayer from \"./ConnectedPlayer\";\nconst { fromServer } = emitTypes;\nexport default (server) => {\n    const io = require(\"socket.io\")(server);\n    GameStateManager.addResetListener((gameState) => io.emit(fromServer.gameReset, gameState.toJS()));\n    GameStateManager.addUpdateListener((gameState) => io.emit(fromServer.gameStateUpdated, gameState.toJS()));\n    io.emit(fromServer.gameReset);\n    io.on(\"connection\", socket => {\n        new ConnectedPlayer(socket);\n    });\n};\n","export default {\n    fromServer: {\n        playerConnected: \"connection made\",\n        gameStateUpdated: \"game state updated\",\n        gameReset: \"game state reset\",\n    },\n    toServer: {\n        initializePlayer: \"initialize player state\",\n        resetGame: \"reset game\",\n        buyCard: \"buy card\",\n        moveChars: \"move chars\",\n    },\n};\n","import * as Immutable from \"immutable\";\nexport default class ArrayUtils {\n    static shuffle(arr) {\n        for (let i = arr.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n        }\n        return arr;\n    }\n    static shuffleImmutable(arr) {\n        // ughhh\n        return Immutable.fromJS(this.shuffle(arr.toJS()));\n    }\n}\n","import * as Immutable from \"immutable\";\nexport default class DeckUtils {\n    static dealAllCardsToDeck(fromDeck, toDeck) {\n        return this.dealCardsToDeck(fromDeck, toDeck, fromDeck.size);\n    }\n    static dealCardsToDeck(fromDeck, toDeck, cardCount) {\n        const dealtCards = DeckUtils.dealCards(fromDeck, cardCount);\n        const newToDeck = this.addCardsToTop(toDeck, dealtCards.dealt);\n        return { fromDeck: dealtCards.deck, toDeck: newToDeck };\n    }\n    static dealCards(deck, cardCount) {\n        return {\n            deck: deck.slice(0, cardCount),\n            dealt: deck.slice(-cardCount),\n        };\n    }\n    static addCardsToTop(deck, cards) {\n        const multiCards = typeof cards === \"string\" ? Immutable.fromJS([cards]) : cards;\n        return deck.concat(multiCards);\n    }\n    static addCardsToBottom(deck, cards) {\n        const multiCards = typeof cards === \"string\" ? Immutable.fromJS([cards]) : cards;\n        return multiCards.concat(deck);\n    }\n}\n","export default class EventDelegate {\n    constructor() {\n        this.listeners = [];\n        this.trigger = (data) => {\n            this.listeners.forEach(listener => listener(data));\n        };\n    }\n    addEventListener(listener) {\n        if (this.listeners.indexOf(listener) === -1)\n            this.listeners.push(listener);\n        else\n            console.warn(\"Listner was already added.\");\n    }\n    removeEventListener(listener) {\n        const index = this.listeners.indexOf(listener);\n        if (index !== -1)\n            this.listeners.splice(index, 1);\n    }\n    clearEventListeners() {\n        this.listeners = [];\n    }\n    getListenerCount() {\n        return this.listeners.length;\n    }\n    hasListeners() {\n        return this.listeners.length !== 0;\n    }\n}\n","export default class LoopUtils {\n    static mapTimes(times, callback) {\n        const arr = [];\n        for (let i = 0; i < times; i++) {\n            arr.push(callback(i));\n        }\n        return arr;\n    }\n}\n","import * as Immutable from \"immutable\";\nimport DeckUtils from \"@utils/DeckUtils\";\nimport ArrayUtils from \"@utils/ArrayUtils\";\nexport default class PlayerUtils {\n    static dealCards(player, cardCount) {\n        const deckSize = player.get(\"deck\").size;\n        if (cardCount > deckSize) {\n            player = this.dealCardsFromDeckToDeck(player, \"deck\", \"hand\", deckSize);\n            player = this.shuffleDiscardToDeck(player);\n            player = this.dealCardsFromDeckToDeck(player, \"deck\", \"hand\", cardCount - deckSize);\n        }\n        else {\n            player = this.dealCardsFromDeckToDeck(player, \"deck\", \"hand\", cardCount);\n        }\n        return player;\n    }\n    static dealCardsFromDeckToDeck(player, fromDeck, toDeck, cardCount) {\n        const fromTo = DeckUtils.dealCardsToDeck(player.get(fromDeck), player.get(toDeck), cardCount);\n        player = player.set(fromDeck, fromTo.fromDeck);\n        player = player.set(toDeck, fromTo.toDeck);\n        return player;\n    }\n    static dealAllCardsFromDeckToDeck(player, fromDeck, toDeck) {\n        return this.dealCardsFromDeckToDeck(player, fromDeck, toDeck, player.get(fromDeck).size);\n    }\n    static shuffleDeck(player, deck) {\n        return player.set(deck, ArrayUtils.shuffleImmutable(player.get(deck)));\n    }\n    static discardHand(player) {\n        return this.dealAllCardsFromDeckToDeck(player, \"hand\", \"discard\");\n    }\n    static shuffleDiscardToDeck(player) {\n        player = this.dealAllCardsFromDeckToDeck(player, \"discard\", \"deck\");\n        return this.shuffleDeck(player, \"deck\");\n    }\n    static addCardToDiscard(player, card) {\n        return player.set(\"discard\", DeckUtils.addCardsToTop(player.get(\"discard\"), card));\n    }\n    static makeTablePlayer(player, playerIndex, boardWidth, boardHeight) {\n        const positions = this.getPlayerPosition(playerIndex, boardWidth, boardHeight);\n        const tablePlayer = player;\n        const chars = player.get(\"chars\");\n        const tableChars = chars.map((char, c) => {\n            const pos = positions.get(c);\n            let tableChar = char;\n            tableChar = tableChar.set(\"maxHP\", char.get(\"hp\"));\n            tableChar = tableChar.set(\"x\", pos.get(\"x\"));\n            tableChar = tableChar.set(\"y\", pos.get(\"y\"));\n            return tableChar;\n        });\n        // FIXME: baaaad typing\n        return tablePlayer.set(\"chars\", tableChars);\n    }\n    static moveChars(player, charMoves) {\n        return null;\n        // player.chars.forEach((char, index) => {\n        // \tconst move = charMoves[index];\n        // \tchar.x = move.x;\n        // \tchar.y = move.y;\n        // });\n    }\n    static getPlayerPosition(playerIndex, boardWidth, boardHeight) {\n        switch (playerIndex) {\n            case 0:\n                return Immutable.fromJS([\n                    { x: 0, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 0, y: 2 },\n                ]);\n            case 1:\n                return Immutable.fromJS([\n                    { x: boardWidth - 1, y: boardHeight - 1 },\n                    { x: boardWidth - 1, y: boardHeight - 2 },\n                    { x: boardWidth - 1, y: boardHeight - 3 },\n                ]);\n            case 2:\n                return Immutable.fromJS([\n                    { x: 0, y: boardHeight - 1 },\n                    { x: 1, y: boardHeight - 1 },\n                    { x: 2, y: boardHeight - 1 },\n                ]);\n            case 3:\n                return Immutable.fromJS([\n                    { x: boardWidth - 1, y: 0 },\n                    { x: boardWidth - 2, y: 0 },\n                    { x: boardWidth - 3, y: 0 },\n                ]);\n            default:\n                throw `Board does not support this many players.  Requested start location for player ${playerIndex + 1},  max player count is 2`;\n        }\n    }\n}\n","module.exports = require(\"express\");","module.exports = require(\"http\");","module.exports = require(\"immutable\");","module.exports = require(\"path\");","module.exports = require(\"socket.io\");"],"sourceRoot":""}